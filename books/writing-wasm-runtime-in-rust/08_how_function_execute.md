---
title: "関数の実行の仕組み"
---

関数を実行するということは関数が持つ命令をループで処理していくということになる。
本章ではWasm Runtimeがどのように関数を処理するかについて解説していく。

## 命令の実行

Wasm Runtimeでは命令の実行は、大きく分けると次のステップがある。

1. プログラムカウンタを使って命令を取得
2. 取得した命令を処理
  - このステップではスタックやローカル変数等の操作も行う
3. プログラムカウンタをカウントアップ

プログラムカウンタは次に実行する命令の番地を指す値のこと。
Wasm Runtimeでは命令は配列となっているので、プログラムカウンタは配列のインデックスの値となる。

これを疑似コードで示すと次のようになる。

```rust
let instructions = vec![...];      // 命令列
let mut stack: Vec<i32> = vec![];  // スタック
let mut locals: Vec<i32> = vec![]; // ローカル変数
let mut pc: usize = 0;             // プログラムカウンタ

loop {
    if let Some(instruction) = instructions.get(pc) else {
        break;
    };

    match instruction {
        inst::LocalGet => { ... }
        inst::I32Add => { ... }
        ...
    }

    pc += 1;
}
```

## フレーム

フレームは関数の実行に必要な次の情報を持つデータ構造のこと。
各種項目の概要については後述する。

- プログラムカウンタ（pc）
- スタックポインタ（sp）
- 命令列（instructions）
- 戻り値の個数（arity）
- 引数・ローカル変数（locals）

関数を実行するときはフレームを作成して、これらの情報を元の処理していく。
今回実装するWasm Runtimeではフレームを次のように表現している。

```rust
#[derive(Default)]
pub struct Frame {
    pub pc: isize,
    pub sp: usize,
    pub insts: Vec<Instruction>,
    pub arity: usize,
    pub locals: Vec<Value>,
}
```

## コールスタック

フレームを保持するためのスタック領域のこと。
関数を実行するときにフレームを作成して、それをコールスタックに`push`する。
関数の実行がが終わるとコールスタックから`pop`される。

コールスタックとフレーム、命令実行の関係性を図に示すと次のとおりである。
プログラムカウンタと命令列は命令フェッチ時に使用され、それ以外の情報は命令を処理時に使われる。

![](/images/about_execution.drawio.png)

## スタックポインタ

コールスタックは関数を実行するたびに積まれるが、スタックは常にひとつである。
そのため、関数間では共通のスタック領域を使うことになる。

共通の領域のため、関数実行が終わったタイミングでスタックを巻き戻する必要がある。

例えばスタックに値を積む処理を持つ`func1`と`func2`があるとする。
`func1`の処理中に`func2`を呼び出す場合、`func2`の処理中に値がスタックに積まれた状態で`func2`の処理が終わり、`func1`の処理に戻るときスタックに`func2`で積んだ値が残ったままになってしまう。
そのため、`func1`が`func2`を呼び出した時点のスタック状態に巻き戻する必要がある。
その際にスタックをどこまで巻き戻すかの情報が必要で、それがスタックポイントである。

## 引数・ローカル変数

Wasmの関数は引数とローカル変数を持つことができる。
引数は実質ローカル変数なので、フレームの`locals`に保存することになる。

関数から関数を呼び出す際に、引数をどのように関数にわたすかについて少し解説する。
まず、関数を実行する前にフレームを作成するが、引数を受け取る関数がある場合はスタックから引数を`pop`して、`locals`に`push`する。

これにより、関数を実行する際にローカル変数を使えるようになる。

## 戻り値の個数

Wasmの関数は戻り値を返すことができる。
関数の実行が終わってスタックが巻き戻されるときに、戻り値がある場合は先にスタックから値を`pop`してから巻き戻す。
その後、`pop`した値をスタックに`push`する。

これにより、関数の実行結果がスタックに積まれた状態になり、呼び出し元で続きの処理を行うことができる。
関数の実行結果がスタックに積まれるということは、`i32.const 1`のようにスタックに`1`を`push`する処理と同等と考えるとイメージしやすいかもしれない。

## まとめ
Wasmにおける関数の実行の仕組みについて解説した。
必要な知識について解説はしたが、実際に実装してみないと理解できないところもあるので、次章から実装をしていく。
