---
title: "Runtimeの実装"
---

前章ではWasmバイナリのデコード処理を実装して、足し算する関数をデコードできるところまで実装した。
本章ではデコードされた関数をどのように実行していくかについて、必要な知識について解説する。

## 前提知識

[Wasmの入門](/books/writing-wasm-runtime-in-rust/03_intro_wasm%252Emd)の「スタックマシンの補足」節で少しだけ説明したが、関数を実行するということは関数が持つ命令をループで処理していくということになる。
しかし、命令の処理を実行する上でいくつか前提知識があるので、まずそれらについて解説する。

### 命令の実行

Wasm Runtimeでは命令の実行は、大きく分けると次のステップがある。

1. プログラムカウンタを使って命令を取得
2. 取得した命令を処理
3. プログラムカウンタをカウントアップ

プログラムカウンタは次に実行する命令の番地を指す値のこと。
Wasm Runtimeでは命令は配列となっているので、プログラムカウンタは配列のインデックスの値となる。

これを疑似コードで示すと次のようになる。

```rust
let instructions = vec![...];      // 命令列
let mut stack: Vec<i32> = vec![];  // スタック
let mut locals: Vec<i32> = vec![]; // ローカル変数
let mut pc: usize = 0;             // 次に実行する命令

loop {
    if let Some(instruction) = instructions.get(pc) else {
        break;
    };

    match instruction {
        inst::LocalGet => {
          let value = locals.pop();
          stack.push(value);
        }
        inst::I32Add => {
          let right = stack.pop();
          let left = stack.pop();
          stack.push(left + right);
        }
        ...
    }

    pc += 1;
}
```

### フレーム

フレームは関数の実行に必要な次の情報を持つデータ構造のこと。

- プログラムカウンタ（pc）
- スタックポインタ（sp）
- 命令列（instructions）
- 引数・ローカル変数（locals）
- 戻り値の個数（arity）

各種項目の概要については後述する。

### コールスタック

フレームを保持するためのスタック領域のこと。
関数を実行するときにフレームを作成して、それをコールスタックに`push`する。
関数の実行がが終わるとコールスタックから`pop`される。

コールスタックとフレーム、命令実行の関係性を図に示すと次のとおりである。
プログラムカウンタと命令列は命令フェッチ時に使用され、それ以外の情報は命令を処理時に使われる。

![](/images/about_execution.drawio.png)

### スタックポインタ

コールスタックは関数を実行するたびに積まれるが、スタックは常にひとつである。
そのため、関数間では共通のスタック領域を使うことになる。

共通の領域のため、関数実行が終わったタイミングでスタックを巻き戻する必要がある。

例えばスタックに値を積む処理を持つ`func1`と`func2`があるとする。
`func1`の処理中に`func2`を呼び出す場合、`func2`の処理中に、値がスタックに積まれた状態で`func2`が終わると、`func1`の処理に戻るときスタックに`func2`で積んだ値が残ったままになってしまう。
そのため、`func1`が`func2`を呼び出した時点のスタック状態に巻き戻する必要がある。
その際にスタックをどこまで巻き戻すかの情報が必要で、それがスタックポイントである。

### 引数・ローカル変数

### 戻り値の個数
