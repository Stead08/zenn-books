---
title: "Runtimeの実装"
---

前章ではWasmバイナリのデコード処理を実装して、足し算する関数をデコードできるところまで実装した。
本章ではデコードされた関数をどのように実行していくかについて、必要な知識について解説する。

## 前提知識

[Wasmの入門](/books/writing-wasm-runtime-in-rust/03_intro_wasm%252Emd)の「スタックマシンの補足」節で少しだけ説明したが、関数を実行するということは関数が持つ命令をループで処理していくということになる。
しかし、命令の処理を実行する上でいくつか前提知識があるので、まずそれらについて解説する。

### 命令の実行

Wasm Runtimeでは命令の実行は、大きく分けると次のステップがある。

1. プログラムカウンタを使って命令を取得
2. 取得した命令を処理
3. プログラムカウンタをカウントアップ

プログラムカウンタは次に実行する命令の番地を指す値のこと。
Wasm Runtimeでは命令は配列となっているので、プログラムカウンタは配列のインデックスの値となる。

### フレーム

関数の実行に必要な次の情報を持つデータ構造。

- プログラムカウンタ（pc）
- スタックポインタ（sp）
- 命令列（instructions）
- 引数・ローカル変数（locals）
- 戻り値の個数（arity）

基本的にこれらの情報を使って関数の命令を処理していくが、
各種情報をどのように使うのかといった、細かい説明は実装時に解説する。

### コールスタック

フレームを保持するためのスタック領域のこと。
関数が呼ばれるとフレームがスタックに`push`され、関数の呼び出しが終わると`pop`され、呼び出し元の関数の処理に戻る。

コールスタックとレーム、命令実行の関係性を図に示すと、次のとおりである。
プログラムカウンタと命令列は命令フェッチのステップで使用され、それ以外の情報は命令を処理するステップで使われる。

![](/images/about_execution.drawio.png)

### スタックポインタ

スタックはフレームと違って複数の関数で利用される。

例えばスタックに何かしらの値を積む処理を持つ`func1`と`func2`があるとする。
`func1`の処理中に`func2`を呼び出す場合、`func1`の処理でスタックに積まれた値をそのままにして`func2`の処理を行う。
`func2`の処理中に、値がスタックに積まれた状態で`func2`が終わると、`func1`の処理に戻るときスタックに`func2`の処理中の値が残ったままになることがある。
そのため、`func1`が`func2`を呼び出した時点のスタック状態に巻き戻する必要がある。[^1]
その際にスタックをどこまで巻き戻すかの情報が必要で、それがスタックポイントである。

[^1]: func2が戻り値を返さない場合
